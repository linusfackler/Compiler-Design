import java_cup.runtime.*;
terminal CLASS;           //2
terminal AND;             //3
terminal ELSE;            //4
terminal IF;              //5
terminal WHILE;           //6
terminal READ;            //7
terminal PRINT;           //8
terminal PRINTLN;         //9
terminal RETURN;          //10
terminal OR;              //11
terminal TIMES;           //12
terminal PLUS;            //13
terminal PLUSPLUS;        //14
terminal MINUS;           //15
terminal MINUSMINUS;      //16
terminal PREFIXPLUS;      //17
terminal PREFIXMINUS;     //18
terminal DIVIDE;          //19
terminal SEMI;            //20
terminal LEFT_PAREN;      //21
terminal RIGHT_PAREN;     //22
terminal LEFT_BRACE;      //23
terminal RIGHT_BRACE;     //24
terminal LEFT_BRACKET;    //25
terminal RIGHT_BRACKET;   //26
terminal EQUAL;           //27
terminal GREATER;         //28
terminal LESS;            //29
terminal LESS_EQ;         //30
terminal GREATER_EQ;      //31
terminal NOT_EQ;          //32
terminal NOT;             //33
terminal QUESTION;        //34
terminal COLON;           //35
terminal ASSIGN;          //36
terminal COMMA;           //37
terminal FINAL;           //38
terminal VOID;            //39
terminal TRUE;            //40
terminal FALSE;           //41
terminal String INT;      //42
terminal String FLOAT;    //43
terminal String BOOL;     //44
terminal String CHAR;     //45
terminal String ID;       //46
terminal int INTLIT;      //47
terminal double FLOATLIT; //48
terminal String CHARLIT;  //49
terminal String STRINGLIT;//50


non terminal Program program;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal String optionalsemi;
non terminal String type;
non terminal IFEnd ifend;
non terminal Name name;
non terminal Args args;
non terminal Readlist readlist;
non terminal Printlist printlist;
non terminal Pintlinelist printlinelist;
non terminal Expr expression;
non terminal TypeExpression typeExpression;
non terminal UnaryExpression unaryExpression;
non terminal Binaryop binaryop;

program ::= stmts:ss
    {: RESULT = new Program(ss); :}
    ;

stmts ::= stmt:s stmts:ss
    {: RESULT = ss.prepend(s); :}
    |
    {: RESULT = new Stmts(); :}
    ;

stmt ::= IF LEFT_PAREN expression:e RIGHT_PAREN LEFT_BRACE stmts:ss RIGHT_BRACE ifend:ie
    {: RESULT = new IfStatement(e,ss,ie); :}
    |
    WHILE LEFT_PAREN expression:e RIGHT_PAREN LEFT_BRACE stmts:ss RIGHT_BRACE
    {: RESULT = new WhileStatement(e,ss); :}
    |
    name:n ASSIGN expression:e SEMI
    {: RESULT = new AssignStatement(n,e); :}
    |
    READ LEFT_PAREN readlist:rl RIGHT_PAREN SEMI
    {: RESULT = new ReadStatement(rl); :}
    |
    PRINT LEFT_PAREN printlist:pl RIGHT_PAREN SEMI
    {: RESULT = new PrintStatement(pl); :}
    |
    PRINTLN LEFT_PAREN printlinelist:pll RIGHT_PAREN SEMI
    {: RESULT = new PrintlnStatement(pll); :}
    |
    ID:i LEFT_PAREN RIGHT_PAREN SEMI
    {: RESULT = new CalllStatement(i); :}
    |
    ID:i LEFT_PAREN args:a RIGHT_PAREN SEMI
    {: RESULT = new CalllStatement(i,a); :}
    |
    RETURN SEMI
    {: RESULT = new ReturnStatement(); :}
    |
    RETURN expression:e SEMI
    {: RESULT = new ReturnStatement(e); :}
    |
    name:n PLUSPLUS SEMI
    {: RESULT = new Increment(n); :}
    |
    name:n MINUSMINUS SEMI
    {: RESULT = new Decrement(n); :}
    |
    LEFT_BRACE stmts ss RIGHT_BRACE optionalsemi:os
    {: RESULT = new BlockCode(ss, os); :}
    ;

optionalsemi ::= SEMI
    {: RESULT = ";"; :}
    |
    {: RESULT = ""; :}
    ;

type ::= INT:i
    {: RESULT = "int"; :}
    |
    CHAR:c
    {: RESULT = "char"; :}
    |
    BOOL:b
    {: RESULT = "bool"; :}
    |
    FLOAT:f
    {: RESULT = "float"; :}
    ;

ifend ::= ELSE LEFT_BRACE stmts:s RIGHT_BRACE
    {: RESULT = new IfEnd(stmts); :}
    |
    {: RESULT = new IfEnd(); :}
    ;

name ::= ID:i
    {: RESULT = new Name(i); :}
    |
    ID:i LEFT_BRACKET expression:e RIGHT_BRACKET
    {: RESULT = new Name(i,e); :}
    ;

args ::= expression:e COMMA args:a
    {: RESULT = a.prepend(e); :}
    |
    expression:e
    {: RESULT = new Args(e); :}
    ;

readlist ::= name:n COMMA readlist:rl
    {: RESULT = rl.prepend(n); :}
    |
    name:n
    {: RESULT = new Readlist(n):}
    ;

printlist ::= expression:e COMMA printlist:pl
    {: RESULT = pl.prepend(e); :}
    |
    expression:e
    {: RESULT = new PrintList(e); :}
    ;

printlinelist ::= printlist:pl
    {: RESULT = new Printlinelist(pl); :}
    |
    {: RESULT = new Printlinelist(); :}
    ;

expression ::= name:n
    {: RESULT = n; :}
    |
    ID:i LEFT_PAREN RIGHT_PAREN
    {: RESULT = new IDExpression(i); :}
    |
    ID:i LEFT_PAREN args:a RIGHT_PAREN
    {: RESULT = new IDExpression(i,a); :}
    |
    LEFT_PAREN expression:e RIGHT_PAREN
    {: RESULT = e; :}
    |
    LEFT_PAREN type:t RIGHT_PAREN expression:e
    {: RESULT = new Typecast(t, e); :}
    |
    unaryExpression:u
    {: RESULT = u; :}
    |
    binaryExpression:b
    {: RESULT = b; :}
    LEFT_PAREN expression:e1 QUESTION expression:e2 COLON expression:e3
    {: RESULT = new ConditionalExpression(e1, e2, e3); :}
    ;

typeExpression ::= INTLIT:i
    {: RESULT = new TypeExpression(i); :}
    |
    CHARLIT:c
    {: RESULT = new TypeExpression(c); :}
    |
    STRINGLIT:s
    {: RESULT = new TypeExpression(s); :}
    |
    FLOATLIT:f
    {: RESULT = new TypeExpression(f); :}
    |
    TRUE
    {: RESULT = new TypeExpression(true); :}
    |
    FALSE
    {: RESULT = new TypeExpression(false); :}
    ;

unaryExpression ::= NOT expression:e
    {: RESULT = new UnaryExpression("~", e); :}
    |
    PREFIXMINUS expression:e
    {: RESULT = new UnaryExpression("-", e); :}
    |
    PREFIXPLUS expression:e
    {: RESULT = new UnaryExpression("+", e); :}
    |

binaryExpression ::= expression:e1 binaryop:b expression:e2
    {: RESULT = new BinaryExpression(e1, b, e2); :}

binaryop ::= TIMES:t
    {: RESULT = t; :}
    |
    DIVIDE:d
    {: RESULT = d; :}
    |
    PLUS:p
    {: RESULT = p; :}
    |
    MINUS:m
    {: RESULT = m; :}
    |
    LESS:l
    {: RESULT = l; :}
    |
    GREATER:g
    {: RESULT = g; :}
    |
    LESS_EQ:le
    {: RESULT = le; :}
    |
    GREATER_EQ:ge
    {: RESULT = ge; :}
    |
    EQUAL:e
    {: RESULT = e; :}
    |
    NOT_EQ:n
    {: RESULT = n; :}
    |
    OR:o
    {: RESULT = o; :}
    |
    AND:a
    {: RESULT = a; :}
    ;